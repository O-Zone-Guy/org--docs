#+title: C++
#+author: Omar Alkersh
#+SETUPFILE: ../theme-readtheorg.setup

* Introduction

  This page is based of my own experience and Stroustrup's book [[http://www.stroustrup.com/4th.html]["C++ Programming Language (4th Edition)]]".

* Language basics

  It is statically typed; the type of every entity must be known to the compiler at compile time. There is no ambiguity about what the type of variable or the signature of any function.

  Stroustrup insists that C++ is a many paradigm language and we would be doing it injustice by calling it an OO language. To fully utilise C++ you need to understand that it has many paradigms that can be used simultaneously.

  C++ is a compiled language. The text file is taken and processed, producing object files, which are linked then yielding an executable.

* Hello, world!

  The minimal program is:

  #+BEGIN_SRC C++
    int main(){} // A function called "main" that takes no arguments.
  #+END_SRC

  All C++ programs must define exactly one global ~main()~ function. This is the entry point of the program. The ~int~ value returned is returned to the system. This is the exit code. A non-zero value is considered an error. Most system do something with the return value, =UNIX= based systems do while =Windows= usually doesn't.

  The ~main()~ function doesn't have to return any value. I believe ~return 0~ is implied.

  Most programs have some sort of output. To print to the screen you need to use ~cout~ which is the ~std~ namespace(will be discussed later). To call it you need to import the relevant library. Here is an example.

  #+NAME: helloWorld
  #+BEGIN_SRC C++ :results output verbatim
    #include <iostream>

    int main() {
      std::cout << "Hello, World.\n";
    }
  #+END_SRC

  If one was to put this program in a file and compile it then run it you will see the following output.

  #+call: helloWorld()

  Here ~#include <iostream>~ tells the compiler to /include/ the ~iostream~ library, which has the standard I/O stream facilities. The line:

  #+BEGIN_SRC C++
  std::cout << "Hello, World.\n";
  #+END_SRC

  would make no sense without it.

  The ~s << a~ operator is a *put to* operator. It inserts the second argument, ~a~, into the stream, ~s~, the precedes it. In this example we put the string ~"Hello, World.\n"~ into the standard output stream ~cout~.

  Strings will be look at later.

  The ~std::~ specifies that ~cout~ is found in the namespace ~std~, the standard library.

  In essence, all code is placed in functions and is called directly, or indirectly, from ~main()~.

* Variables and expressions
  
  In C++ there are 5 types of 'elementary' types; ~bool~, ~char~, ~int~, ~double~, and ~float~. They hold same values and behave similarly to other programming languages.

** Declaration and Initialisation
   
   To declare a variable you specify its type followed by an identifier, the name.

   #+BEGIN_SRC C++ 
     type varName;
   #+END_SRC

   Initialising a variable is to give it a value. In C++ this can be done in multiple different ways. You have the traditional method using '=' the *curly-braced-delimited initialiser list*. Both methods can be mixed.
   
   #+caption: = initialisaiton
   #+BEGIN_SRC C++
     int i = 5;
   #+END_SRC


   #+caption: Braces initialisaiton
   #+BEGIN_SRC C++
     int i {5};
   #+END_SRC

   #+caption: Mixed initialisaiton
   #+BEGIN_SRC C++
     int i = {5};
   #+END_SRC

   All the previous methods initialisation are equivalent.

** Arithmetic operations

   C++ comes with the usual mathematical operators:
   #+BEGIN_SRC C++
     x+y                             // plus
     +x                              // unary plus
     x-y                             // minus
     -x                              // unary minus
     x*y                             // multiply
     x/y                             //divide
     x%y                             // remainder/Modulus
#+END_SRC

   It also comes with boolean operations:
   #+BEGIN_SRC C++
     x == y;                         // equal
     x != y;                         // not equal
     x<y;                            // less than
     x>y;                            // greater than
     x <= y;                         // less than or equal
     x >= y                          // greater than or equal
#+END_SRC

** The ~auto~ Keyword

   When I first saw the ~auto~ keyword in C++ I was rather confused. When I learned what it does I was even more confused!

   The ~auto~ keyword is used in variable declaration instead of the type. It does exactly what it sounds it does: automatically sets the type of the variable.

   It is used as such:

   #+BEGIN_SRC C++
     auto varName;
#+END_SRC

#+RESULTS:

   The 'issue' here is that C++ is statically typed language. So how does C++ know what type to use? What if I declare a variable then initialise it later? More importantly, why would I ever use anything else for variable declaration?
   
   To answer the first question, C++ will not allow you to declare a variable with the ~auto~ keyword without initialisation. So it will always use the type of the data it is being set to.
   
   Regarding the second question, in every day to day coding there is none! The only reason to not use it either one of those:

   1) The definition is used in a large scope and you want to be clear to the reader what type this variable/method is.
   2) You want to explicitly state the type of the variable(~float~ instead of ~double~).
   
   So yeah. Always use auto unless you *have* to explicitly state the type, or you cannot initialise a variable on declaration.
   
   Regarding late initialisation, Bjarne Stroustrup advices to never introduce a variable if you don't have a value to give it to.

** Constants
   C++ supports two notions of constants:
   - ~cosnt~: Roughly meaning “I promise to never change it.” This is useful in defining interfaces, so that we may pass data without fear of modification. The compiler will enforce this promise, will throw an exception it detects possible modification.
   - ~constexpr~: Means roughly “to be evaluated at compile time.” This what you want to use when defining constants.

     
   Examples

   #+BEGIN_SRC C++
     double sum(const vector<double>&); // sum will not modify its arguments
     vector<double> v {1, 2, 3, 4, 5};  // v is not a constant, it can be modidied
     const double s1     = sum(v);      // OK;    evaluated at runtime, but cannot be changed later
     constexpr double s2 = sum(v);      // error; sum(v) is not a constant expression.
   #+END_SRC

    For a function to be ~constexpr~ it needs to be rather simple; just a ~return~ statement computing a value. It can have non constant arguments, but when that is done it will not be a ~constexpr~.
    
   Example
   #+BEGIN_SRC C++
     constexpr double square(double x) {return x * x;}
   #+END_SRC

** Pointers, References and Arrays.
*** Arrays
    
    Arrays are a list of variables of the same type and with a fixed length. They are declared as such:

    #+BEGIN_SRC C++
      type varName[6];
    #+END_SRC
    #+CAPTION: An array of type ~type~ and length 6 which is called =varName=;
    
    Arrays' index start from ~0~. So for =varName= it stats from ~varName[0]~ and ends at ~varName[5]~.


* Read Also
#+CALL: ../code_snippets.org:get-list(ignore_pattern="c\\+\\+")
